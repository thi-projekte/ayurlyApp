# Quarkus Application Configuration
quarkus.application.name=ayurly-data-service
quarkus.application.version=1.0

# HTTP Server
quarkus.http.port=18080

# --- Datenbankverbindung ---
quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=${POSTGRES_USER}
quarkus.datasource.password=${POSTGRES_PASSWORD}
quarkus.datasource.jdbc.url=${QUARKUS_DATASOURCE_JDBC_URL}
# Beispiel: QUARKUS_DATASOURCE_JDBC_URL=jdbc:postgresql://ayurly-postgres-db:5432/ayurly_data_db

# Hibernate ORM # Optionen: none, create, drop-and-create, drop, update, validate
quarkus.hibernate-orm.database.generation=${QUARKUS_HIBERNATE_ORM_DATABASE_GENERATION}
quarkus.hibernate-orm.log.sql=${QUARKUS_HIBERNATE_ORM_LOG_SQL}

# Für @Valid Annotation in den DTOs
quarkus.hibernate-validator.enabled=true

# --- MicroProfile JWT Konfiguration für Keycloak Token Validierung ---
# URL zum JWKS (JSON Web Key Set) Endpunkt deines Keycloak Realms.
# Quarkus holt sich von hier die öffentlichen Schlüssel zur Signaturprüfung.
# Ersetze <KEYCLOAK_HOSTNAME> und <REALM_NAME> durch deine Werte (oder verwende Env-Vars).
mp.jwt.verify.publickey.location=${KEYCLOAK_AUTH_SERVER_URL}/protocol/openid-connect/certs
# Beispiel: mp.jwt.verify.publickey.location=https://keycloak.winfprojekt.de/realms/Aryuveda/protocol/openid-connect/certs

# Der erwartete Issuer (Aussteller) der Tokens. Muss exakt mit dem 'iss'-Claim im JWT übereinstimmen.
# Ersetze <KEYCLOAK_HOSTNAME> und <REALM_NAME> (oder verwende Env-Vars).
mp.jwt.verify.issuer=${KEYCLOAK_AUTH_SERVER_URL}
# Beispiel: mp.jwt.verify.issuer=https://keycloak.winfprojekt.de/realms/Aryuveda

# (Optional, aber empfohlen) Die erwartete Audience.
# Dies ist typischerweise die Client-ID deines Backend-Services in Keycloak.
# Wenn du mehrere Audiences erlauben möchtest, kannst du eine kommaseparierte Liste angeben.
# quarkus.smallrye.jwt.require-jwt=true # Stellt sicher, dass JWT-basierte Security aktiv ist
mp.jwt.verify.audiences=${KEYCLOAK_BACKEND_CLIENT_ID}
# Beispiel: quarkus.smallrye.jwt.verify.audiences=ayurly-backend-api

smallrye.jwt.path.groups=realm_access/roles
smallrye.jwt.claims.groups=realm_access/roles

# --- falls doch Keycloak OIDC verwendet wird ---
# Falls dein Data-Service als OIDC Resource Server agiert.
# Passe die Property-Namen an deine tatsächliche Quarkus OIDC Konfiguration an.
# quarkus.oidc.auth-server-url=${KEYCLOAK_AUTH_SERVER_URL}
# quarkus.oidc.client-id=${KEYCLOAK_BACKEND_CLIENT_ID}
# quarkus.oidc.credentials.secret=${KEYCLOAK_BACKEND_CLIENT_SECRET} # Für vertrauliche Clients

# --- Dateiupload-Konfiguration ---
# Pfad innerhalb des Containers, in den Dateien hochgeladen werden.
# Dieser Pfad wird auf ein Docker-Volume gemappt.
app.upload.directory=/deployments/uploads

# --- Logging ---
quarkus.log.level=INFO




# Kleinere Anpassung für SmallRye OpenAPI (Swagger UI)
# Standardpfad für OpenAPI Spezifikation
# Standardpfad für Swagger UI
# Swagger UI auch im Prod-Modus verfügbar machen (optional, für Entwicklung praktisch)
# Achtung: Keine Whitespaces hinter der URI, sonst failed build
quarkus.smallrye-openapi.path=/q/openapi
quarkus.swagger-ui.path=/q/swagger-ui
quarkus.swagger-ui.always-include=true
# Wir definieren ein Security Scheme vom Typ 'HTTP Bearer Authentication'.
quarkus.smallrye-openapi.security-scheme-extensions.jwtAuth.type=http
quarkus.smallrye-openapi.security-scheme-extensions.jwtAuth.scheme=bearer
quarkus.smallrye-openapi.security-scheme-extensions.jwtAuth.bearer-format=JWT